#!/usr/bin/env python3
"""Play a role recording from an offset until the next silence."""
from __future__ import annotations

from dataclasses import dataclass
import logging
from pathlib import Path
import subprocess
import sys

import typer

ROOT = Path(__file__).resolve().parent
SRC = ROOT / "src"
if str(SRC) not in sys.path:
    sys.path.insert(0, str(SRC))

from play_config import PlayConfig
from pydub import AudioSegment
from pydub.silence import detect_silence


@dataclass
class AudioCheck:
    base_dir: Path
    min_silence_ms: int = 1500
    silence_delta_db: float = 16.0

    def command(
        self,
        role: str = typer.Argument(..., metavar="ROLE"),
        offset_ms: int = typer.Argument(..., metavar="OFFSET-MS"),
        continue_play: bool = typer.Option(
            False,
            "--continue",
            help="Keep playing past the detected silence",
        ),
        offset_mod: float = typer.Option(
            0.0,
            "--offset-mod",
            help="Seconds to adjust the start time (negative for earlier)",
        ),
    ) -> None:
        raise SystemExit(self.run(role, offset_ms, continue_play, offset_mod))

    def run(
        self,
        role: str,
        offset_ms: int,
        continue_play: bool,
        offset_mod: float,
    ) -> int:
        if offset_ms < 0:
            raise RuntimeError("Offset must be a non-negative integer (ms)")
        offset_mod_ms = int(round(offset_mod * 1000))
        start_ms = max(0, offset_ms + offset_mod_ms)
        start_seconds = start_ms / 1000.0
        config = PlayConfig.load(self.base_dir)
        audio_path = (
            self.base_dir
            / "plays"
            / config.play_id
            / "recordings"
            / f"{role}.wav"
        )
        if not audio_path.exists():
            raise RuntimeError(f"Recording not found: {audio_path}")
        audio = AudioSegment.from_file(audio_path)
        if start_ms >= len(audio):
            raise RuntimeError("Offset is beyond the end of the recording")
        stop_ms = None
        if not continue_play:
            silence_start = self._find_next_silence_start(audio, start_ms)
            stop_ms = min(len(audio), silence_start + 1000)
        logging.info(
            "Starting ffplay for %s at %dms%s",
            audio_path,
            start_ms,
            "" if stop_ms is None else f" (stops at {stop_ms}ms)",
        )
        command = [
            "ffplay",
            "-nodisp",
            "-loglevel",
            "error",
            "-ss",
            f"{start_seconds:.3f}",
        ]
        if stop_ms is not None:
            duration_ms = max(0, stop_ms - start_ms)
            duration_seconds = duration_ms / 1000.0
            command.extend(["-t", f"{duration_seconds:.3f}", "-autoexit"])
        command.extend(["-i", str(audio_path)])
        return subprocess.call(command)

    def _find_next_silence_start(self, audio: AudioSegment, start_ms: int) -> int:
        silence_thresh = self._silence_threshold(audio)
        segment = audio[start_ms:]
        silences = detect_silence(
            segment,
            min_silence_len=self.min_silence_ms,
            silence_thresh=silence_thresh,
        )
        if silences:
            return start_ms + silences[0][0]
        return len(audio)

    def _silence_threshold(self, audio: AudioSegment) -> float:
        if audio.dBFS == float("-inf"):
            return -60.0
        return audio.dBFS - self.silence_delta_db


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="%(message)s")
    app = typer.Typer(add_completion=False)
    checker = AudioCheck(base_dir=ROOT)
    app.command()(checker.command)
    try:
        app()
    except KeyboardInterrupt:
        raise SystemExit(130)
